name: Deploy Backend to App Runner

on:
  push:
    branches:
      - main
      - features/pipeline_backend
    paths:
      - 'backend/**'
      - '.github/workflows/app-runner-deploy.yml'
  workflow_dispatch:
    inputs:
      stage:
        description: 'Deployment stage (dev/staging/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-1' }}
  STAGE: ${{ inputs.stage || 'dev' }}
  NODE_VERSION: '24'

jobs:
  # Deploy Backend to App Runner
  deploy-app-runner:
    name: Deploy Backend to App Runner
    runs-on: ubuntu-latest
    environment: ${{ inputs.stage || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          echo "Installing backend dependencies..."
          npm ci
          echo "Dependencies installed successfully"

      - name: Build backend
        working-directory: ./backend
        env:
          NODE_ENV: production
        run: |
          echo "Building backend application..."
          npm run build
          
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "ERROR: Build completed but dist folder is empty or missing"
            exit 1
          fi
          
          # Verify main.js is built (NestJS builds to dist/src/)
          if [ ! -f "dist/src/main.js" ]; then
            echo "ERROR: main.js not found in dist/src/ after build"
            echo "Checking what files were built:"
            find dist -name "*.js" -type f | head -20
            exit 1
          fi
          
          echo "âœ… Build completed successfully"
          echo "âœ… main.js found in dist/src/"
          ls -lh dist/src/main.js

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR repository URI
        id: ecr-repo
        run: |
          STAGE="${{ env.STAGE }}"
          REPO_NAME="${STAGE}-flowgenie-backend"
          
          # Check if repository exists (should be created by Terraform)
          if ! aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "ERROR: ECR repository '$REPO_NAME' does not exist"
            echo "Please run infrastructure deployment first (infra-deploy workflow)"
            exit 1
          fi
          
          # Get repository URI
          REPO_URI=$(aws ecr describe-repositories \
            --repository-names "$REPO_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          
          echo "ECR Repository: $REPO_URI"
          echo "ecr_repository=$REPO_URI" >> $GITHUB_ENV
          echo "ecr_repo_name=$REPO_NAME" >> $GITHUB_ENV

      - name: Build, tag, and push Docker image to Amazon ECR
        working-directory: ./backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ecr_repo_name }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image..."
          docker build \
            -f Dockerfile \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "Pushing Docker image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "âœ… Docker image pushed successfully"
          echo "  Image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "  Latest: $ECR_REGISTRY/$ECR_REPOSITORY:latest"
          echo "ecr_image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Get App Runner service details
        id: get-app-runner
        run: |
          STAGE="${{ env.STAGE }}"
          SERVICE_NAME="${STAGE}-flowgenie-apprunner-backend"
          
          echo "Checking App Runner service: $SERVICE_NAME"
          
          # Get service ARN
          SERVICE_ARN=$(aws apprunner list-services \
            --region ${{ env.AWS_REGION }} \
            --query "ServiceSummaryList[?ServiceName=='$SERVICE_NAME'].ServiceArn" \
            --output text)
          
          if [ -z "$SERVICE_ARN" ] || [ "$SERVICE_ARN" == "None" ]; then
            echo "ERROR: App Runner service '$SERVICE_NAME' does not exist"
            echo "Please run infrastructure deployment first (infra-deploy workflow)"
            exit 1
          fi
          
          SERVICE_URL=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region ${{ env.AWS_REGION }} \
            --query 'Service.ServiceUrl' \
            --output text)
          
          echo "App Runner Service ARN: $SERVICE_ARN"
          echo "App Runner Service URL: $SERVICE_URL"
          echo "service_arn=$SERVICE_ARN" >> $GITHUB_ENV
          echo "service_url=$SERVICE_URL" >> $GITHUB_ENV
          
          echo "âœ… App Runner service found"
          echo "Service URL: $SERVICE_URL"

      - name: Update App Runner environment variables
        env:
          # Secrets from GitHub Secrets
          APP_URL: ${{ secrets.APP_URL }}
          AWS_DYNAMODB: ${{ secrets.AWS_DYNAMODB }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DEVOPS_TOKEN: ${{ secrets.DEVOPS_TOKEN }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          GOOGLE_APPLICATION_CREDENTIALS: ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_SERVICE_ACCOUNT: ${{ secrets.GOOGLE_SERVICE_ACCOUNT }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          REDIS_AUTH_TOKEN: ${{ secrets.REDIS_AUTH_TOKEN }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          # Variables from GitHub Variables
          AMPLIFY_BRANCH_NAME: ${{ vars.AMPLIFY_BRANCH_NAME }}
          AMPLIFY_DOMAIN: ${{ vars.AMPLIFY_DOMAIN }}
          AMPLIFY_REPOSITORY_URL: ${{ vars.AMPLIFY_REPOSITORY_URL }}
          BACKEND_ENVIRONMENT_VARIABLES: ${{ vars.BACKEND_ENVIRONMENT_VARIABLES }}
          DB_NAME: ${{ vars.DB_NAME }}
          DB_USERNAME: ${{ vars.DB_USERNAME }}
          ENABLE_SWAGGER: ${{ vars.ENABLE_SWAGGER }}
          FRONTEND_ENVIRONMENT_VARIABLES: ${{ vars.FRONTEND_ENVIRONMENT_VARIABLES }}
          GOOGLE_CLIENT_ID: ${{ vars.GOOGLE_CLIENT_ID }}
          GOOGLE_PROJECT_NAME: ${{ vars.GOOGLE_PROJECT_NAME }}
          GOOGLE_REDIRECT_URI: ${{ vars.GOOGLE_REDIRECT_URI }}
          JWT_EXPIRES_IN: ${{ vars.JWT_EXPIRES_IN }}
          REFRESH_TOKEN_EXPIRES_IN: ${{ vars.REFRESH_TOKEN_EXPIRES_IN }}
          STAGE_VAR: ${{ vars.STAGE }}
        run: |
          SERVICE_ARN="${{ env.service_arn }}"
          STAGE="${{ env.STAGE }}"
          
          # Ensure jq is available
          if ! command -v jq &> /dev/null; then
            echo "jq is required but not installed. Installing..."
            sudo apt-get update && sudo apt-get install -y jq
          fi
          
          echo "Updating App Runner environment variables from GitHub Secrets and Variables..."
          
          # Get current App Runner service configuration
          SERVICE_CONFIG=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region ${{ env.AWS_REGION }} \
            --output json)
          
          CURRENT_ENV=$(echo "$SERVICE_CONFIG" | jq -r '.Service.SourceConfiguration.ImageRepository.ImageConfiguration.RuntimeEnvironmentVariables // {}')
          
          echo "Current App Runner environment variables:"
          echo "$CURRENT_ENV" | jq '.'
          
          # Start with current environment variables
          UPDATED_ENV=$(echo "$CURRENT_ENV" | jq -c '.')
          
          # List of all secrets to inject (from GitHub Secrets)
          SECRETS=(
            "APP_URL"
            "AWS_DYNAMODB"
            "CORS_ORIGINS"
            "DATABASE_URL"
            "DB_PASSWORD"
            "DEVOPS_TOKEN"
            "FRONTEND_URL"
            "GOOGLE_APPLICATION_CREDENTIALS"
            "GOOGLE_CLIENT_SECRET"
            "GOOGLE_SERVICE_ACCOUNT"
            "JWT_SECRET"
            "REDIS_URL"
            "REDIS_HOST"
            "REDIS_PORT"
            "REDIS_AUTH_TOKEN"
          )
          
          # List of all variables to inject (from GitHub Variables)
          VARIABLES=(
            "AMPLIFY_BRANCH_NAME"
            "AMPLIFY_DOMAIN"
            "AMPLIFY_REPOSITORY_URL"
            "BACKEND_ENVIRONMENT_VARIABLES"
            "DB_NAME"
            "DB_USERNAME"
            "ENABLE_SWAGGER"
            "FRONTEND_ENVIRONMENT_VARIABLES"
            "GOOGLE_CLIENT_ID"
            "GOOGLE_PROJECT_NAME"
            "GOOGLE_REDIRECT_URI"
            "JWT_EXPIRES_IN"
            "REFRESH_TOKEN_EXPIRES_IN"
            "STAGE"
          )
          
          # Inject secrets
          echo ""
          echo "ðŸ” Injecting secrets from GitHub Secrets..."
          for secret_name in "${SECRETS[@]}"; do
            # Get the value from environment (mapped from secrets)
            secret_value=$(eval echo \$$secret_name)
            
            if [ -n "$secret_value" ] && [ "$secret_value" != "" ]; then
              echo "  Setting $secret_name (masked)"
              UPDATED_ENV=$(echo "$UPDATED_ENV" | jq -c --arg key "$secret_name" --arg value "$secret_value" '. + {($key): $value}')
            else
              echo "  âš ï¸  $secret_name not set in GitHub Secrets, skipping"
            fi
          done
          
          # Inject variables
          echo ""
          echo "ðŸ“ Injecting variables from GitHub Variables..."
          for var_name in "${VARIABLES[@]}"; do
            # Handle special case: STAGE_VAR -> STAGE
            env_var_name="$var_name"
            if [ "$var_name" = "STAGE" ]; then
              env_var_name="STAGE_VAR"
            fi
            
            # Get the value from environment (mapped from vars)
            var_value=$(eval echo \$$env_var_name)
            
            if [ -n "$var_value" ] && [ "$var_value" != "" ]; then
              echo "  Setting $var_name = $var_value"
              UPDATED_ENV=$(echo "$UPDATED_ENV" | jq -c --arg key "$var_name" --arg value "$var_value" '. + {($key): $value}')
            else
              echo "  âš ï¸  $var_name not set in GitHub Variables, skipping"
            fi
          done
          
          # Set NODE_ENV based on STAGE if not already set
          if [ -z "$(echo "$UPDATED_ENV" | jq -r '.NODE_ENV // empty')" ]; then
            NODE_ENV_VALUE="production"
            if [ "$STAGE" != "prod" ]; then
              NODE_ENV_VALUE="$STAGE"
            fi
            echo "  Setting NODE_ENV=$NODE_ENV_VALUE"
            UPDATED_ENV=$(echo "$UPDATED_ENV" | jq -c --arg env "$NODE_ENV_VALUE" '. + {NODE_ENV: $env}')
          fi
          
          # Get current service configuration to preserve other settings
          IMAGE_URI=$(echo "$SERVICE_CONFIG" | jq -r '.Service.SourceConfiguration.ImageRepository.ImageIdentifier')
          ACCESS_ROLE_ARN=$(echo "$SERVICE_CONFIG" | jq -r '.Service.SourceConfiguration.AuthenticationConfiguration.AccessRoleArn')
          PORT=$(echo "$SERVICE_CONFIG" | jq -r '.Service.SourceConfiguration.ImageRepository.ImageConfiguration.Port // 3000')
          
          # Create update configuration JSON
          UPDATE_CONFIG=$(jq -n \
            --arg image_uri "$IMAGE_URI" \
            --arg access_role_arn "$ACCESS_ROLE_ARN" \
            --arg port "$PORT" \
            --argjson env_vars "$UPDATED_ENV" \
            '{
              "SourceConfiguration": {
                "ImageRepository": {
                  "ImageIdentifier": $image_uri,
                  "ImageConfiguration": {
                    "Port": ($port | tonumber),
                    "RuntimeEnvironmentVariables": $env_vars
                  },
                  "ImageRepositoryType": "ECR"
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": $access_role_arn
                },
                "AutoDeploymentsEnabled": true
              }
            }')
          
          # Check if update is needed
          CURRENT_ENV_STR=$(echo "$CURRENT_ENV" | jq -c -S '.')
          UPDATED_ENV_STR=$(echo "$UPDATED_ENV" | jq -c -S '.')
          
          if [ "$CURRENT_ENV_STR" != "$UPDATED_ENV_STR" ]; then
            echo ""
            echo "Updating App Runner service environment variables..."
            
            # Save update config to temp file
            UPDATE_CONFIG_FILE=$(mktemp)
            echo "$UPDATE_CONFIG" > "$UPDATE_CONFIG_FILE"
            
            # Update App Runner service
            aws apprunner update-service \
              --service-arn "$SERVICE_ARN" \
              --source-configuration "file://$UPDATE_CONFIG_FILE" \
              --region ${{ env.AWS_REGION }} > /dev/null
            
            echo "âœ… App Runner service environment variables updated"
            echo "Waiting for service update to complete..."
            
            # Wait for service update
            aws apprunner wait service-updated \
              --service-arn "$SERVICE_ARN" \
              --region ${{ env.AWS_REGION }}
            
            echo "âœ… App Runner service update completed"
            
            # Clean up temp file
            rm -f "$UPDATE_CONFIG_FILE"
          else
            echo ""
            echo "âœ… No changes detected - environment variables are up to date"
          fi
          
          echo ""
          echo "Updated App Runner environment variables:"
          echo "$UPDATED_ENV" | jq '.'

      - name: Wait for App Runner to deploy new image
        run: |
          SERVICE_ARN="${{ env.service_arn }}"
          MAX_WAIT=600
          ELAPSED=0
          
          echo "Waiting for App Runner to deploy new image..."
          echo "App Runner will automatically deploy when new image is pushed to ECR"
          echo "(Auto-deploy must be enabled in App Runner configuration)"
          
          # Wait for deployment to start (check if new deployment is in progress)
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get current operation status
            OPERATION_STATUS=$(aws apprunner list-operations \
              --service-arn "$SERVICE_ARN" \
              --region ${{ env.AWS_REGION }} \
              --query 'OperationSummaryList[0].Status' \
              --output text 2>/dev/null || echo "UNKNOWN")
            
            if [ "$OPERATION_STATUS" == "IN_PROGRESS" ] || [ "$OPERATION_STATUS" == "PENDING" ]; then
              echo "Deployment in progress... (Status: $OPERATION_STATUS, Elapsed: ${ELAPSED}s)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            else
              echo "Deployment status: $OPERATION_STATUS"
              break
            fi
          done
          
          # Get service status
          SERVICE_STATUS=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region ${{ env.AWS_REGION }} \
            --query 'Service.Status' \
            --output text)
          
          echo "App Runner Service Status: $SERVICE_STATUS"
          
          if [ "$SERVICE_STATUS" == "RUNNING" ]; then
            echo "âœ… App Runner service is running"
          else
            echo "âš ï¸  App Runner service status: $SERVICE_STATUS"
          fi

      - name: Display deployment information
        run: |
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App Runner Service:** ${{ env.STAGE }}-flowgenie-apprunner-backend" >> $GITHUB_STEP_SUMMARY
          echo "**Service URL:** ${{ env.service_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** ECR Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.ecr_image_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Backend deployed successfully to App Runner" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Environment variables updated from GitHub Secrets and Variables" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Note: App Runner automatically deploys when new images are pushed to ECR" >> $GITHUB_STEP_SUMMARY
          echo "(Auto-deploy must be enabled in App Runner configuration)" >> $GITHUB_STEP_SUMMARY
